## 浏览器缓存机制

简单高效的性能优化方式：缓存，

优秀的缓存策略：可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网路负荷

（ps：我们的产品并没有用到缓存机制，因为to 2 的云产品一定要保证资源的准确性，所以这边发送请求就是真正的从数据库取读）

一个请求可以分为：发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一步和第三步中优化性能。

比如：直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据



一、缓存位置

缓存位置分四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，蔡虎去请求网路

1、Service Worker

这个是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用这个的话，传输协议必须死用HTTPS。因为Service Worker中设计到请求拦截，所以必须使用HTTPS协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何取读缓存，并且缓存是持续性的。

（ps：这边应当确保service worker的初始化安装不会恶化用户的首次网文体验）

使用指南：这个实现缓存功能一不能分为三个步骤：首先需要先注册Service Worker，然后监听到install事件以后就可以缓存需要的文件。那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请去数据 

当Service Worker没有命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从Memory Cache中还是从网络请求中获取数据，浏览器都会显示是从service worker中获取内容

2、Memory Cache

内存中的缓存，主要包含当**前页面中已经抓取的资源**，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭tab页面，内存中的缓存也就被释放了（计算机的内存比磁盘的容量小得多，一般存储一些被取读高频次的数据）

内存缓存中有一块重要的缓存资源是**preloader**相关指令（例如<link rel="prefetch">）下载的资源。众所周知preloader的相关指令已经是页面优化的常用手段之一，它可以一边解析js/css文件，一边网络请求下一个资源

3、Disk Cache

存储在硬盘中的缓存，读取速度慢点，但是什么东西都可以存储在它上面，胜在时效性和容量上

会根据HTTP Header中字段的判断哪些字眼需要缓存，哪些资源可以不清去直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自Disk Cache

4、Push Cache

推送缓存是HTTP/2中的内容，当以上三种缓存都没有命中时，它才会被使用，它只在session（会话）中存在，一旦会话结束就被释放，并且缓存的时间也很短暂，在Chrome浏览器中只有5分钟，同时它也并非严格执行HTTP头的缓存指令





前端性能优化：

 https://www.cnblogs.com/lanxiansen/p/10972802.html 

1、减少请求资源大小或者次数

压缩js、css文件

2、尽量使用字体图标或者svg来代替传统的png图（因为其是代码编写的，放大不会变形，而且渲染速度快）

3、使用图片懒加载

4、能用css就不要用js（尽量减少第三方插件的引用）

5、使用雪碧图或者精灵图

6、减少对cookie的使用

8、请求数据多用json（数据处理方便，资源偏小）少用xml

代码中

1、少用闭包（会导致内存泄漏）

2、避免手动dom操作（主要减少dom的重绘与回流）

5、减少css表达式的使用

6、尽量减少使用递归，建议使用尾递归





Chrome为什么打开一个页面，会有4个进程

目前的多进程架构Chrome包括， 1个浏览器主进程，1个GPU进程，1个网络进程，多个渲染进程，多个插件进程。

所以打开一个页面，至少需要1个网络进程，一个浏览器进程，1个GPU进程，以及一个渲染进程。





